"""
Bright Data Unlocker API ile Cloudflare Bypass
Bu mod√ºl Selenium yerine Bright Data'nƒ±n profesyonel Unlocker API'sini kullanƒ±r
"""

import requests
import time
import logging
from bs4 import BeautifulSoup
from config.settings import Config

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AppointmentChecker:
    def __init__(self):
        self.config = Config()
        self.session = requests.Session()
        
    def fetch_with_brightdata(self, url, max_retries=2):
        """
        Bright Data Unlocker API ile sayfa getir
        
        Args:
            url: Hedef URL
            max_retries: Maksimum deneme sayƒ±sƒ±
            
        Returns:
            tuple: (success: bool, html: str, status_code: int)
        """
        logger.info(f"üåê Bright Data Unlocker API ile sayfa getiriliyor: {url}")
        
        # API Key kontrol√º
        api_key = self.config.BRIGHTDATA_API_KEY
        if not api_key:
            logger.error("‚ùå BRIGHTDATA_API_KEY bulunamadƒ±!")
            return False, "", 0
        
        logger.info(f"üîë API Key (ilk 10 karakter): {api_key[:10]}...")
        
        # Bright Data Web Unlocker API endpoint
        api_url = "https://api.brightdata.com/request"
        
        # API Headers
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        
        # Request payload (Bright Data format)
        payload = {
            "zone": "web_unlocker1",  # Zone name (default for Web Unlocker)
            "url": url,
            "format": "raw",  # Raw HTML response
            "country": "tr"   # Turkey proxy (TESTED: WORKS!)
        }
        
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"üîÑ Deneme {attempt}/{max_retries}...")
                
                response = self.session.post(
                    api_url,
                    json=payload,
                    headers=headers,
                    timeout=45  # 45 saniye (test sonu√ßlarƒ±na g√∂re optimize edildi - max 44.74s g√∂r√ºld√º)
                )
                
                # Debug logging
                logger.info(f"üì° Response Status: {response.status_code}")
                logger.info(f"üì° Response Headers: {dict(response.headers)}")
                logger.info(f"üì° Response Content-Type: {response.headers.get('Content-Type', 'N/A')}")
                logger.info(f"üì° Response Length: {len(response.content)} bytes")
                logger.info(f"üì° Response Text Length: {len(response.text)} chars")
                
                if len(response.text) > 0:
                    logger.info(f"üì° Response Preview (first 500 chars): {response.text[:500]}")
                
                if response.status_code == 200:
                    if len(response.text) == 0:
                        # Navigation timeout kontrol√º
                        brd_error = response.headers.get('x-brd-error', '')
                        if 'navigation timeout' in brd_error.lower():
                            logger.warning(f"‚ö†Ô∏è Navigation timeout! Deneme {attempt}/{max_retries}")
                            if attempt < max_retries:
                                logger.info(f"üîÑ {attempt * 3}s bekleyip tekrar denenecek...")
                                time.sleep(attempt * 3)
                                continue
                        
                        logger.error("‚ùå Response bo≈ü! API yanƒ±t veriyor ama i√ßerik yok")
                        logger.error(f"üí° Full Response: {response.content}")
                        logger.error(f"üí° Request Payload: {payload}")
                        return False, "", response.status_code
                    
                    logger.info(f"‚úÖ Sayfa ba≈üarƒ±yla getirildi! (Status: {response.status_code})")
                    logger.info(f"üìä Response boyutu: {len(response.text)} karakter")
                    return True, response.text, response.status_code
                    
                elif response.status_code == 401:
                    logger.error("‚ùå Bright Data API Key ge√ßersiz!")
                    logger.error("üí° BRIGHTDATA_API_KEY environment variable'ƒ± kontrol edin")
                    return False, "", response.status_code
                    
                elif response.status_code == 429:
                    logger.warning(f"‚ö†Ô∏è Rate limit a≈üƒ±ldƒ±, {attempt * 5}s bekleniyor...")
                    time.sleep(attempt * 5)
                    continue
                    
                else:
                    logger.warning(f"‚ö†Ô∏è Beklenmeyen status code: {response.status_code}")
                    logger.warning(f"   Response: {response.text[:200]}")
                    
                    if attempt < max_retries:
                        logger.info(f"üîÑ {attempt * 3}s sonra tekrar denenecek...")
                        time.sleep(attempt * 3)
                        continue
                        
            except requests.exceptions.Timeout:
                logger.error(f"‚ùå Timeout hatasƒ±! (Deneme {attempt}/{max_retries})")
                if attempt < max_retries:
                    time.sleep(attempt * 3)
                    continue
                    
            except requests.exceptions.RequestException as e:
                logger.error(f"‚ùå Request hatasƒ±: {e}")
                if attempt < max_retries:
                    time.sleep(attempt * 3)
                    continue
                    
            except Exception as e:
                logger.error(f"‚ùå Beklenmeyen hata: {e}")
                if attempt < max_retries:
                    time.sleep(attempt * 3)
                    continue
        
        logger.error(f"‚ùå {max_retries} denemeden sonra ba≈üarƒ±sƒ±z!")
        return False, "", 0
    
    def extract_captcha_from_html(self, html):
        """
        HTML'den CAPTCHA g√∂rselini √ßƒ±kar
        
        Args:
            html: Sayfa HTML i√ßeriƒüi
            
        Returns:
            str: CAPTCHA base64 data URL veya None
        """
        try:
            # Use lxml parser for better performance
            soup = BeautifulSoup(html, 'lxml')
            
            logger.info("üîç CAPTCHA g√∂rseli aranƒ±yor...")
            logger.info(f"üìä HTML boyutu: {len(html)} karakter")
            
            # CAPTCHA g√∂rseli ara
            captcha_img = soup.find('img', class_='imageCaptcha')
            
            if captcha_img:
                logger.info("‚úÖ img.imageCaptcha elementi bulundu!")
                src = captcha_img.get('src', '')
                logger.info(f"üì° src attribute: {src[:100]}...")
                
                if src and src.startswith('data:image'):
                    logger.info("‚úÖ CAPTCHA g√∂rseli HTML'de bulundu!")
                    logger.info(f"üìä Base64 boyutu: {len(src)} karakter")
                    return src
                else:
                    logger.warning(f"‚ö†Ô∏è src attribute ge√ßersiz: {src[:50]}")
            else:
                logger.warning("‚ö†Ô∏è img.imageCaptcha elementi bulunamadƒ±")
                
                # Debug: T√ºm img elementlerini listele
                all_imgs = soup.find_all('img')
                logger.info(f"üìä Toplam img elementi: {len(all_imgs)}")
                for idx, img in enumerate(all_imgs[:5]):  # ƒ∞lk 5'i g√∂ster
                    logger.info(f"   img[{idx}]: class={img.get('class', [])} src={str(img.get('src', ''))[:50]}...")
                    
            logger.warning("‚ö†Ô∏è CAPTCHA g√∂rseli HTML'de bulunamadƒ±")
            return None
            
        except Exception as e:
            logger.error(f"‚ùå CAPTCHA extraction hatasƒ±: {e}")
            return None
    
    def submit_captcha(self, captcha_text):
        """
        CAPTCHA kodunu POST et ve form sayfasƒ±nƒ± al
        
        Args:
            captcha_text: Mistral AI tarafƒ±ndan √ß√∂z√ºlen CAPTCHA metni
            
        Returns:
            tuple: (success: bool, html: str)
        """
        try:
            target_url = "https://it-tr-appointment.idata.com.tr/tr"
            api_url = "https://api.brightdata.com/request"
            
            logger.info(f"üì§ CAPTCHA POST ediliyor: {captcha_text}")
            logger.info(f"üéØ Hedef URL: {target_url}")
            
            # Form data hazƒ±rla
            payload = {
                "zone": "web_unlocker1",
                "url": target_url,
                "format": "raw",
                "country": "tr",
                "method": "POST",
                "headers": {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "Referer": target_url,
                    "Origin": "https://it-tr-appointment.idata.com.tr"
                },
                "body": f"mailConfirmCode={captcha_text}"
            }
            
            headers = {
                "Authorization": f"Bearer {self.config.BRIGHTDATA_API_KEY}",
                "Content-Type": "application/json"
            }
            
            logger.info("üîÑ POST isteƒüi g√∂nderiliyor...")
            response = requests.post(
                api_url,
                json=payload,
                headers=headers,
                timeout=45  # 45 saniye timeout (test sonu√ßlarƒ±na g√∂re optimize edildi)
            )
            
            logger.info(f"üì° Response Status: {response.status_code}")
            
            if response.status_code == 200:
                html = response.text
                logger.info(f"üìä Form sayfasƒ± boyutu: {len(html)} karakter")
                
                # HTML'i k√º√ß√ºk harfe √ßevir (performans i√ßin sadece bir kez)
                html_lower = html.lower()
                
                # Form sayfasƒ± kontrol√º (geli≈ütirilmi≈ü)
                form_indicators = [
                    "appointment-form",
                    "ba≈üvuru bilgileri",
                    "ikametgah ≈üehri",
                    "idata ofisi se√ßiniz",
                    "gidi≈ü amacƒ±",
                    "hizmet t√ºr√º"
                ]
                
                error_indicators = [
                    "yanlƒ±≈ü",
                    "hatalƒ±",
                    "ge√ßersiz",
                    "invalid",
                    "incorrect",
                    "wrong"
                ]
                
                # Form sayfasƒ± mƒ±?
                if any(indicator in html_lower for indicator in form_indicators):
                    logger.info("‚úÖ Form sayfasƒ±na y√∂nlendirme ba≈üarƒ±lƒ±!")
                    logger.info("üìã Ba≈üvuru formu sayfasƒ± tespit edildi")
                    return True, html
                
                # Hata sayfasƒ± mƒ±?
                if any(error in html_lower for error in error_indicators):
                    logger.warning("‚ö†Ô∏è CAPTCHA kodu yanlƒ±≈ü girildi!")
                    return False, None
                
                # Belirsiz ama HTML var
                logger.info("‚ÑπÔ∏è Sayfa i√ßeriƒüi belirsiz, HTML d√∂nd√ºr√ºl√ºyor")
                logger.info(f"üìÑ HTML Preview: {html[:200]}...")
                return True, html
            else:
                logger.error(f"‚ùå POST ba≈üarƒ±sƒ±z: {response.status_code}")
                return False, None
                
        except Exception as e:
            logger.error(f"‚ùå CAPTCHA POST hatasƒ±: {e}")
            return False, None
    
    def fill_appointment_form(self, form_html):
        """
        Form sayfasƒ±nƒ± doldur ve randevu kontrol√º yap
        
        ƒ∞zmir se√ßenekleri:
        - ≈ûehir: ƒ∞zmir
        - Ofis: ƒ∞zmir Ofisi
        - Gidi≈ü Amacƒ±: Turistik
        - Hizmet T√ºr√º: Standart
        - Ki≈üi Sayƒ±sƒ±: 1
        
        Args:
            form_html: Form sayfasƒ±nƒ±n HTML i√ßeriƒüi
            
        Returns:
            tuple: (success: bool, result_html: str or None)
        """
        try:
            logger.info("üìù Form doldurma ba≈ülatƒ±lƒ±yor...")
            
            # Form sayfasƒ±ndaki select option'larƒ± parse et
            soup = BeautifulSoup(form_html, 'html.parser')
            
            # 1. ≈ûehir se√ßimi i√ßin option deƒüerlerini al (dinamik bekleme ile)
            izmir_option = None
            max_retries = 3  # Maksimum 3 deneme
            
            for attempt in range(1, max_retries + 1):
                logger.info(f"üèôÔ∏è ≈ûehir se√ßenekleri kontrol ediliyor (Deneme {attempt}/{max_retries})...")
                
                # HTML'i yeniden parse et (her denemede)
                soup = BeautifulSoup(form_html, 'html.parser')
                city_select = soup.find('select', {'id': 'city_id'})
                
                if city_select:
                    options = city_select.find_all('option')
                    logger.info(f"üìä {len(options)} ≈üehir se√ßeneƒüi bulundu")
                    
                    # ƒ∞zmir'i ara
                    for option in options:
                        option_text = option.get_text().strip().lower()
                        if 'izmir' in option_text and option.get('value'):
                            izmir_option = option.get('value')
                            logger.info(f"‚úÖ ƒ∞zmir bulundu: value={izmir_option}, text={option.get_text().strip()}")
                            break
                    
                    if izmir_option:
                        break  # ƒ∞zmir bulundu, d√∂ng√ºden √ßƒ±k
                    else:
                        logger.warning(f"‚ö†Ô∏è ƒ∞zmir bulunamadƒ±, 2 saniye bekleniyor...")
                        if attempt < max_retries:
                            time.sleep(2)
                            # Sayfayƒ± yeniden getir
                            logger.info("üîÑ Sayfa yeniden getiriliyor...")
                            _, form_html, _ = self.fetch_with_brightdata(self.config.APPOINTMENT_URL)
                else:
                    logger.warning(f"‚ö†Ô∏è city_id select elementi bulunamadƒ±, 2 saniye bekleniyor...")
                    if attempt < max_retries:
                        time.sleep(2)
                        # Sayfayƒ± yeniden getir
                        _, form_html, _ = self.fetch_with_brightdata(self.config.APPOINTMENT_URL)
            
            if not izmir_option:
                logger.error("‚ùå ƒ∞zmir se√ßeneƒüi bulunamadƒ± (3 deneme sonrasƒ±)!")
                logger.info("üìã Bulunan se√ßenekler:")
                if city_select:
                    for opt in city_select.find_all('option'):
                        logger.info(f"   - value={opt.get('value')}, text={opt.get_text().strip()}")
                return False, None
            
            # 2. ƒ∞lk POST: ≈ûehir se√ßimi (ƒ∞zmir)
            logger.info("üì§ POST 1/4: ≈ûehir se√ßimi (ƒ∞zmir)...")
            city_payload = {
                "zone": "web_unlocker1",
                "url": self.config.APPOINTMENT_URL,
                "format": "raw",
                "country": "tr",
                "method": "POST",
                "body": f"city_id={izmir_option}"
            }
            
            api_url = "https://api.brightdata.com/request"
            headers = {
                "Authorization": f"Bearer {self.config.BRIGHTDATA_API_KEY}",
                "Content-Type": "application/json"
            }
            
            response = requests.post(api_url, json=city_payload, headers=headers, timeout=45)
            
            if response.status_code != 200:
                logger.error(f"‚ùå ≈ûehir se√ßimi ba≈üarƒ±sƒ±z: {response.status_code}")
                return False, None
            
            logger.info("‚úÖ ƒ∞zmir se√ßildi, ofis se√ßenekleri y√ºkleniyor...")
            time.sleep(3)  # Server'ƒ±n ofis se√ßeneklerini y√ºklemesini bekle
            
            # 3. ƒ∞kinci GET: Ofis se√ßeneklerini al (dinamik bekleme ile)
            izmir_office = None
            
            for attempt in range(1, max_retries + 1):
                logger.info(f"üè¢ Ofis se√ßenekleri kontrol ediliyor (Deneme {attempt}/{max_retries})...")
                
                office_soup = BeautifulSoup(response.text, 'html.parser')
                office_select = office_soup.find('select', {'id': 'office_id'})
                
                if office_select:
                    options = office_select.find_all('option')
                    logger.info(f"üìä {len(options)} ofis se√ßeneƒüi bulundu")
                    
                    # ƒ∞zmir Ofisi'ni ara
                    for option in options:
                        option_text = option.get_text().strip().lower()
                        if 'izmir' in option_text and option.get('value'):
                            izmir_office = option.get('value')
                            logger.info(f"‚úÖ ƒ∞zmir Ofisi bulundu: value={izmir_office}, text={option.get_text().strip()}")
                            break
                    
                    if izmir_office:
                        break  # ƒ∞zmir Ofisi bulundu
                    else:
                        logger.warning(f"‚ö†Ô∏è ƒ∞zmir Ofisi bulunamadƒ±, 2 saniye bekleniyor...")
                        if attempt < max_retries:
                            time.sleep(2)
                else:
                    logger.warning(f"‚ö†Ô∏è office_id select elementi bulunamadƒ±, 2 saniye bekleniyor...")
                    if attempt < max_retries:
                        time.sleep(2)
            
            if not izmir_office:
                logger.error("‚ùå ƒ∞zmir Ofisi bulunamadƒ± (3 deneme sonrasƒ±)!")
                logger.info("üìã Bulunan ofis se√ßenekleri:")
                if office_select:
                    for opt in office_select.find_all('option'):
                        logger.info(f"   - value={opt.get('value')}, text={opt.get_text().strip()}")
                return False, None
            
            # 4. ƒ∞kinci POST: Ofis se√ßimi
            logger.info("üì§ POST 2/4: Ofis se√ßimi (ƒ∞zmir Ofisi)...")
            office_payload = {
                "zone": "web_unlocker1",
                "url": self.config.APPOINTMENT_URL,
                "format": "raw",
                "country": "tr",
                "method": "POST",
                "body": f"city_id={izmir_option}&office_id={izmir_office}"
            }
            
            response = requests.post(api_url, json=office_payload, headers=headers, timeout=45)
            
            if response.status_code != 200:
                logger.error(f"‚ùå Ofis se√ßimi ba≈üarƒ±sƒ±z: {response.status_code}")
                return False, None
            
            logger.info("‚úÖ ƒ∞zmir Ofisi se√ßildi, vize tipleri y√ºkleniyor...")
            time.sleep(2)
            
            # 5. √ú√ß√ºnc√º GET: Vize tipi ve hizmet t√ºr√º se√ßeneklerini al
            visa_soup = BeautifulSoup(response.text, 'html.parser')
            
            # Gidi≈ü amacƒ± (purpose)
            purpose_select = visa_soup.find('select', {'id': 'visa_purpose_id'})
            tourist_purpose = None
            
            if purpose_select:
                logger.info("üéØ Gidi≈ü amacƒ± bulundu, Turistik aranƒ±yor...")
                options = purpose_select.find_all('option')
                for option in options:
                    if 'turist' in option.get_text().lower():
                        tourist_purpose = option.get('value')
                        logger.info(f"‚úÖ Turistik bulundu: value={tourist_purpose}")
                        break
            
            # Hizmet t√ºr√º (service type)
            service_select = visa_soup.find('select', {'id': 'service_type_id'})
            standard_service = None
            
            if service_select:
                logger.info("üõ†Ô∏è Hizmet t√ºr√º bulundu, Standart aranƒ±yor...")
                options = service_select.find_all('option')
                for option in options:
                    if 'standart' in option.get_text().lower() or 'standard' in option.get_text().lower():
                        standard_service = option.get('value')
                        logger.info(f"‚úÖ Standart bulundu: value={standard_service}")
                        break
            
            if not tourist_purpose or not standard_service:
                logger.warning("‚ö†Ô∏è Vize tipi veya hizmet t√ºr√º bulunamadƒ±!")
                return False, None
            
            # 6. √ú√ß√ºnc√º POST: Vize tipi ve hizmet t√ºr√º se√ßimi
            logger.info("üì§ POST 3/4: Turistik + Standart se√ßimi...")
            visa_payload = {
                "zone": "web_unlocker1",
                "url": self.config.APPOINTMENT_URL,
                "format": "raw",
                "country": "tr",
                "method": "POST",
                "body": f"city_id={izmir_option}&office_id={izmir_office}&visa_purpose_id={tourist_purpose}&service_type_id={standard_service}"
            }
            
            response = requests.post(api_url, json=visa_payload, headers=headers, timeout=45)
            
            if response.status_code != 200:
                logger.error(f"‚ùå Vize tipi se√ßimi ba≈üarƒ±sƒ±z: {response.status_code}")
                return False, None
            
            logger.info("‚úÖ Turistik + Standart se√ßildi, ki≈üi sayƒ±sƒ± ayarlanƒ±yor...")
            time.sleep(2)
            
            # 7. D√∂rd√ºnc√º POST: Ki≈üi sayƒ±sƒ± (1 ki≈üi)
            logger.info("üì§ POST 4/4: Ki≈üi sayƒ±sƒ± (1 ki≈üi)...")
            count_payload = {
                "zone": "web_unlocker1",
                "url": self.config.APPOINTMENT_URL,
                "format": "raw",
                "country": "tr",
                "method": "POST",
                "body": f"city_id={izmir_option}&office_id={izmir_office}&visa_purpose_id={tourist_purpose}&service_type_id={standard_service}&applicant_count=1"
            }
            
            response = requests.post(api_url, json=count_payload, headers=headers, timeout=45)
            
            if response.status_code != 200:
                logger.error(f"‚ùå Ki≈üi sayƒ±sƒ± ayarƒ± ba≈üarƒ±sƒ±z: {response.status_code}")
                return False, None
            
            logger.info("‚úÖ Form doldurma tamamlandƒ±!")
            logger.info("üìä Son sayfa HTML boyutu: {} karakter".format(len(response.text)))
            
            return True, response.text
            
        except Exception as e:
            logger.error(f"‚ùå Form doldurma hatasƒ±: {e}")
            return False, None
    
    def check_appointment_availability(self, html):
        """
        HTML'den randevu durumunu kontrol et
        
        Args:
            html: Sayfa HTML i√ßeriƒüi
            
        Returns:
            tuple: (available: bool, message: str)
        """
        try:
            soup = BeautifulSoup(html, 'html.parser')
            text = soup.get_text().lower()
            
            logger.info("üîç Randevu durumu kontrol ediliyor...")
            
            # Form sayfasƒ±nda mƒ±yƒ±z? (CAPTCHA ge√ßildiyse)
            if "appointment-form" in html or "BA≈ûVURU Bƒ∞LGƒ∞LERƒ∞" in html:
                logger.info("üìã Form sayfasƒ±nda - Randevu se√ßenekleri aranƒ±yor...")
                
                # "Uygun randevu yok" alert div
                no_appointment_alert = soup.find('div', class_='alert-danger')
                if no_appointment_alert and "Uygun randevu tarihi bulunmamaktadƒ±r" in no_appointment_alert.get_text():
                    logger.info("üòî 'Uygun randevu tarihi bulunmamaktadƒ±r' mesajƒ± bulundu")
                    return False, "üòî Randevu yok"
                
                # "ƒ∞LERƒ∞" butonu var mƒ±? (Randevu varsa g√∂r√ºn√ºr)
                ileri_button = soup.find('a', id='btnAppCountNext')
                if ileri_button and hasattr(ileri_button, 'get'):
                    style = str(ileri_button.get('style', ''))
                    if 'display: none' not in style:
                        logger.info("‚úÖ 'ƒ∞LERƒ∞' butonu aktif - RANDEVU VAR!")
                        return True, "üéâ RANDEVU VAR!"
                
                logger.info("‚ÑπÔ∏è Form sayfasƒ± y√ºklendi ama randevu durumu belirsiz")
                return False, "‚ÑπÔ∏è Form sayfasƒ± - durum belirsiz"
            
            # ƒ∞lk sayfa (CAPTCHA sayfasƒ±)
            # "Randevu yok" mesajlarƒ±
            no_appointment_keywords = [
                "no appointment",
                "randevu yok",
                "m√ºsait randevu yok",
                "no available appointment"
            ]
            
            for keyword in no_appointment_keywords:
                if keyword in text:
                    logger.info(f"üòî '{keyword}' mesajƒ± bulundu - Randevu yok")
                    return False, "üòî Randevu yok"
            
            # Randevu butonlarƒ± ara (ilk sayfada)
            appointment_count = text.count('randevu') + text.count('appointment')
            if appointment_count > 0:
                logger.info(f"üéâ Randevu referanslarƒ± bulundu! ({appointment_count} adet)")
                return True, f"üéâ RANDEVU VAR! ({appointment_count} referans)"
            
            logger.info("‚ÑπÔ∏è Net bir sonu√ß bulunamadƒ±, daha fazla analiz gerekli")
            return False, "‚ÑπÔ∏è Belirsiz durum"
            
        except Exception as e:
            logger.error(f"‚ùå HTML analiz hatasƒ±: {e}")
            return False, f"‚ùå Hata: {e}"
    
    def run_check(self, progress_callback=None):
        """
        Ana kontrol d√∂ng√ºs√º - Bright Data Unlocker API ile
        
        Args:
            progress_callback: Progress g√ºncellemesi i√ßin callback fonksiyonu
        
        Returns:
            dict: {
                'status': str,  # Sonu√ß mesajƒ±
                'captcha_image': str or None,  # Base64 CAPTCHA g√∂rseli
                'captcha_text': str or None    # √á√∂z√ºlen CAPTCHA metni
            }
        """
        result = {
            'status': "Kontrol ba≈ülatƒ±lƒ±yor...",
            'captcha_image': None,
            'captcha_text': None
        }
        
        def update_progress(step, message):
            """Progress callback helper"""
            if progress_callback:
                progress_callback(step, message)
        
        try:
            logger.info("üöÄ Kontrol ba≈ülatƒ±lƒ±yor...")
            logger.info("üåê Bright Data Unlocker API kullanƒ±lƒ±yor (Selenium YOK!)")
            
            # 1. Sayfa getir (Cloudflare bypass dahil!)
            update_progress(1, "URL'ye baƒülanƒ±lƒ±yor...")
            success, html, status_code = self.fetch_with_brightdata(self.config.APPOINTMENT_URL)
            
            if not success:
                logger.error("‚ùå Sayfa getirilemedi!")
                result['status'] = "‚ùå Baƒülantƒ± hatasƒ±"
                return result
            
            # 2. Cloudflare kontrol√º
            update_progress(2, "Cloudflare kontrol√º...")
            if "cloudflare" in html.lower() or "attention required" in html.lower():
                logger.error("‚ùå Bright Data bile Cloudflare'ƒ± ge√ßemedi!")
                logger.error("üí° Bu √ßok nadir bir durum, API key'i kontrol edin")
                result['status'] = "‚ùå Cloudflare bypass ba≈üarƒ±sƒ±z"
                return result
            
            logger.info("‚úÖ Cloudflare ba≈üarƒ±yla bypass edildi!")
            logger.info(f"üìÑ HTML boyutu: {len(html)} karakter")
            
            # 3. CAPTCHA var mƒ± kontrol et
            update_progress(3, "CAPTCHA algƒ±lanƒ±yor...")
            captcha_data = self.extract_captcha_from_html(html)
            
            if captcha_data:
                logger.info("üîê CAPTCHA bulundu, Mistral AI ile √ß√∂z√ºl√ºyor...")
                
                # CAPTCHA g√∂rselini kaydet
                result['captcha_image'] = captcha_data
                
                from src.captcha_solver import CaptchaSolver
                solver = CaptchaSolver(self.config.MISTRAL_API_KEY)
                
                # CAPTCHA'yƒ± √ß√∂z
                update_progress(3, "CAPTCHA √ß√∂z√ºl√ºyor (Mistral AI)...")
                captcha_text = solver.solve_captcha_from_base64(captcha_data)
                
                if captcha_text:
                    logger.info(f"‚úÖ CAPTCHA √ß√∂z√ºld√º: {captcha_text}")
                    
                    # CAPTCHA metnini kaydet
                    result['captcha_text'] = captcha_text
                    
                    # CAPTCHA kodunu POST et
                    update_progress(4, "CAPTCHA g√∂nderiliyor...")
                    logger.info("üì§ CAPTCHA kodu POST ediliyor...")
                    success, form_html = self.submit_captcha(captcha_text)
                    
                    if success and form_html:
                        logger.info("‚úÖ CAPTCHA POST ba≈üarƒ±lƒ±, form sayfasƒ± alƒ±ndƒ±!")
                        html = form_html  # Yeni HTML'i kullan
                        
                        # Form doldurma adƒ±mƒ± ekle
                        update_progress(5, "Form doldurma (ƒ∞zmir/Turistik/Standart/1 ki≈üi)...")
                        logger.info("üìù Form doldurma ba≈ülatƒ±lƒ±yor...")
                        form_success, final_html = self.fill_appointment_form(form_html)
                        
                        if form_success and final_html:
                            logger.info("‚úÖ Form ba≈üarƒ±yla dolduruldu!")
                            html = final_html  # Son HTML'i kullan
                        else:
                            logger.warning("‚ö†Ô∏è Form doldurulamadƒ±, mevcut HTML kullanƒ±lacak")
                    else:
                        logger.warning("‚ö†Ô∏è CAPTCHA POST ba≈üarƒ±sƒ±z, ilk sayfadaki HTML kullanƒ±lacak")
                else:
                    logger.warning("‚ö†Ô∏è CAPTCHA √ß√∂z√ºlemedi!")
            else:
                logger.info("‚ÑπÔ∏è CAPTCHA bulunamadƒ± veya gerekli deƒüil")
            
            # 4. Randevu durumunu kontrol et
            update_progress(6, "Randevu durumu kontrol ediliyor...")
            available, message = self.check_appointment_availability(html)
            
            # 5. Sonu√ß analizi
            update_progress(7, "Sonu√ß analiz ediliyor...")
            
            logger.info(f"üìä Sonu√ß: {message}")
            result['status'] = message
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Kritik hata: {e}")
            import traceback
            logger.error(traceback.format_exc())
            result['status'] = f"‚ùå Hata: {e}"
            return result
        
        finally:
            logger.info("üîö Kontrol tamamlandƒ±")
    
    def cleanup(self):
        """Temizlik i≈ülemleri"""
        logger.info("üßπ Temizlik yapƒ±lƒ±yor...")
        self.session.close()
        logger.info("‚úÖ Session kapatƒ±ldƒ±")

def main():
    """Test i√ßin"""
    checker = AppointmentChecker()
    result = checker.run_check()
    print(f"\n{'='*60}")
    print(f"SONU√á: {result}")
    print(f"{'='*60}\n")
    checker.cleanup()

if __name__ == "__main__":
    main()
